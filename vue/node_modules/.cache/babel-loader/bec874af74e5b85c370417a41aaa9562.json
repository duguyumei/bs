{"ast":null,"code":"import { defineComponent, getCurrentInstance, ref, computed, unref, nextTick, onMounted, onUpdated, h, resolveDynamicComponent } from 'vue';\nimport { isNumber, isClient } from '@vueuse/core';\nimport '../../../../utils/index.mjs';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { useGridWheel } from '../hooks/use-grid-wheel.mjs';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport { virtualizedGridProps } from '../props.mjs';\nimport { isRTL, getRTLOffsetType, getScrollDir } from '../utils.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, FORWARD, BACKWARD, RTL_OFFSET_POS_DESC, RTL_OFFSET_NAG, AUTO_ALIGNMENT, RTL, RTL_OFFSET_POS_ASC } from '../defaults.mjs';\nimport { getScrollBarWidth } from '../../../../utils/dom/scroll.mjs';\nimport { hasOwn, isString } from '@vue/shared';\n\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n\n    setup(props, {\n      emit,\n      expose,\n      slots\n    }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const cache = ref(initCache(props, instance));\n      const windowRef = ref();\n      const hScrollbar = ref();\n      const vScrollbar = ref();\n      const innerRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      const getItemStyleCache = useCache();\n      const parsedHeight = computed(() => parseInt(`${props.height}`, 10));\n      const parsedWidth = computed(() => parseInt(`${props.width}`, 10));\n      const columnsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          columnCache\n        } = props;\n        const {\n          isScrolling,\n          xAxisScrollDir,\n          scrollLeft\n        } = unref(states);\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, unref(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, unref(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const rowsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          rowCache\n        } = props;\n        const {\n          isScrolling,\n          yAxisScrollDir,\n          scrollTop\n        } = unref(states);\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, unref(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, unref(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight(props, unref(cache)));\n      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth(props, unref(cache)));\n      const windowStyle = computed(() => {\n        var _a;\n\n        return [{\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        }, {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width\n        }, (_a = props.style) != null ? _a : {}];\n      });\n      const innerStyle = computed(() => {\n        const width = `${unref(estimatedTotalWidth)}px`;\n        const height = `${unref(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width\n        };\n      });\n\n      const emitEvents = () => {\n        const {\n          totalColumn,\n          totalRow\n        } = props;\n\n        if (totalColumn > 0 && totalRow > 0) {\n          const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = unref(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = unref(rowsToRender);\n          emit(ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);\n        }\n\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir\n        } = unref(states);\n        emit(SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);\n      };\n\n      const onScroll = e => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n\n        const _states = unref(states);\n\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n\n        let _scrollLeft = scrollLeft;\n\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        states.value = { ..._states,\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        };\n        nextTick(resetIsScrolling);\n        emitEvents();\n      };\n\n      const onVerticalScroll = (distance, totalSteps) => {\n        const height = unref(parsedHeight);\n        const offset = (estimatedTotalHeight.value - height) / totalSteps * distance;\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset)\n        });\n      };\n\n      const onHorizontalScroll = (distance, totalSteps) => {\n        const width = unref(parsedWidth);\n        const offset = (estimatedTotalWidth.value - width) / totalSteps * distance;\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset)\n        });\n      };\n\n      const {\n        onWheel\n      } = useGridWheel({\n        atXStartEdge: computed(() => states.value.scrollLeft <= 0),\n        atXEndEdge: computed(() => states.value.scrollLeft >= estimatedTotalWidth.value),\n        atYStartEdge: computed(() => states.value.scrollTop <= 0),\n        atYEndEdge: computed(() => states.value.scrollTop >= estimatedTotalHeight.value)\n      }, (x, y) => {\n        var _a, _b, _c, _d;\n\n        (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);\n        (_d = (_c = hScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);\n        const width = unref(parsedWidth);\n        const height = unref(parsedHeight);\n        scrollTo({\n          scrollLeft: Math.min(states.value.scrollLeft + x, estimatedTotalWidth.value - width),\n          scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)\n        });\n      });\n\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n\n        const _states = unref(states);\n\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n\n        states.value = { ..._states,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        };\n        nextTick(resetIsScrolling);\n      };\n\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {\n        const _states = unref(states);\n\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = getScrollBarWidth();\n\n        const _cache = unref(cache);\n\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const {\n          columnWidth,\n          direction,\n          rowHeight\n        } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, unref(cache));\n\n          const _cache = unref(cache);\n\n          const rtl = isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n\n      onMounted(() => {\n        if (!isClient) return;\n        const {\n          initScrollLeft,\n          initScrollTop\n        } = props;\n        const windowElement = unref(windowRef);\n\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n\n        emitEvents();\n      });\n      onUpdated(() => {\n        const {\n          direction\n        } = props;\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested\n        } = unref(states);\n        const windowElement = unref(windowRef);\n\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG:\n                {\n                  windowElement.scrollLeft = -scrollLeft;\n                  break;\n                }\n\n              case RTL_OFFSET_POS_ASC:\n                {\n                  windowElement.scrollLeft = scrollLeft;\n                  break;\n                }\n\n              default:\n                {\n                  const {\n                    clientWidth,\n                    scrollWidth\n                  } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                  break;\n                }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      });\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n\n      const renderScrollbars = () => {\n        const {\n          totalColumn,\n          totalRow\n        } = props;\n        const width = unref(parsedWidth);\n        const height = unref(parsedHeight);\n        const estimatedWidth = unref(estimatedTotalWidth);\n        const estimatedHeight = unref(estimatedTotalHeight);\n        const {\n          scrollLeft,\n          scrollTop\n        } = unref(states);\n        const horizontalScrollbar = h(ScrollBar, {\n          ref: hScrollbar,\n          clientSize: width,\n          layout: \"horizontal\",\n          onScroll: onHorizontalScroll,\n          ratio: width * 100 / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true\n        });\n        const verticalScrollbar = h(ScrollBar, {\n          ref: vScrollbar,\n          clientSize: height,\n          layout: \"vertical\",\n          onScroll: onVerticalScroll,\n          ratio: height * 100 / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true\n        });\n        return {\n          horizontalScrollbar,\n          verticalScrollbar\n        };\n      };\n\n      const renderItems = () => {\n        var _a;\n\n        const [columnStart, columnEnd] = unref(columnsToRender);\n        const [rowStart, rowEnd] = unref(rowsToRender);\n        const {\n          data,\n          totalColumn,\n          totalRow,\n          useIsScrolling\n        } = props;\n        const children = [];\n\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              children.push((_a = slots.default) == null ? void 0 : _a.call(slots, {\n                columnIndex: column,\n                data,\n                key: column,\n                isScrolling: useIsScrolling ? unref(states).isScrolling : void 0,\n                style: getItemStyle(row, column),\n                rowIndex: row\n              }));\n            }\n          }\n        }\n\n        return children;\n      };\n\n      const renderInner = () => {\n        const Inner = resolveDynamicComponent(props.innerElement);\n        const children = renderItems();\n        return [h(Inner, {\n          style: unref(innerStyle),\n          ref: innerRef\n        }, !isString(Inner) ? {\n          default: () => children\n        } : children)];\n      };\n\n      const renderWindow = () => {\n        const Container = resolveDynamicComponent(props.containerElement);\n        const {\n          horizontalScrollbar,\n          verticalScrollbar\n        } = renderScrollbars();\n        const Inner = renderInner();\n        return h(\"div\", {\n          key: 0,\n          class: \"el-vg__wrapper\"\n        }, [h(Container, {\n          class: props.className,\n          style: unref(windowStyle),\n          onScroll,\n          onWheel,\n          ref: windowRef\n        }, !isString(Container) ? {\n          default: () => Inner\n        } : Inner), horizontalScrollbar, verticalScrollbar]);\n      };\n\n      return renderWindow;\n    }\n\n  });\n};\n\nexport { createGrid as default };","map":{"version":3,"mappings":"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","names":["createGrid","name","clearCache","getColumnPosition","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getEstimatedTotalHeight","getEstimatedTotalWidth","getColumnOffset","getRowOffset","getRowPosition","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initCache","validateProps","defineComponent","props","virtualizedGridProps","emits","ITEM_RENDER_EVT","SCROLL_EVT","setup","emit","expose","slots","instance","getCurrentInstance","cache","ref","windowRef","hScrollbar","vScrollbar","innerRef","states","isScrolling","scrollLeft","isNumber","initScrollLeft","scrollTop","initScrollTop","updateRequested","xAxisScrollDir","FORWARD","yAxisScrollDir","getItemStyleCache","useCache","parsedHeight","computed","parseInt","height","parsedWidth","width","columnsToRender","totalColumn","totalRow","columnCache","unref","startIndex","stopIndex","cacheBackward","BACKWARD","Math","max","cacheForward","min","rowsToRender","rowCache","estimatedTotalHeight","estimatedTotalWidth","windowStyle","_a","position","overflow","WebkitOverflowScrolling","willChange","direction","style","innerStyle","pointerEvents","emitEvents","columnCacheStart","columnCacheEnd","columnVisibleStart","columnVisibleEnd","rowCacheStart","rowCacheEnd","rowVisibleStart","rowVisibleEnd","onScroll","e","clientHeight","clientWidth","scrollHeight","scrollWidth","currentTarget","_states","_scrollLeft","isRTL","getRTLOffsetType","RTL_OFFSET_NAG","RTL_OFFSET_POS_DESC","value","getScrollDir","nextTick","resetIsScrolling","onVerticalScroll","distance","totalSteps","offset","scrollTo","onHorizontalScroll","onWheel","useGridWheel","atXStartEdge","atXEndEdge","atYStartEdge","atYEndEdge","x","y","_b","_c","_d","onMouseUp","call","scrollToItem","rowIndex","columnIdx","alignment","AUTO_ALIGNMENT","scrollBarWidth","getScrollBarWidth","_cache","estimatedHeight","estimatedWidth","getItemStyle","columnIndex","columnWidth","rowHeight","itemStyleCache","key","hasOwn","left","rtl","top","right","onMounted","isClient","windowElement","onUpdated","RTL","RTL_OFFSET_POS_ASC","renderScrollbars","horizontalScrollbar","h","Scrollbar","clientSize","layout","ratio","scrollFrom","total","visible","verticalScrollbar","renderItems","columnStart","columnEnd","rowStart","rowEnd","data","useIsScrolling","children","row","column","push","default","renderInner","Inner","resolveDynamicComponent","innerElement","isString","renderWindow","Container","containerElement","class","className"],"sources":["../../../../../../../packages/components/virtual-list/src/builders/build-grid.ts"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  ref,\n  nextTick,\n  onMounted,\n  onUpdated,\n  resolveDynamicComponent,\n  h,\n  unref,\n} from 'vue'\nimport { isClient } from '@vueuse/core'\nimport {\n  hasOwn,\n  isNumber,\n  isString,\n  getScrollBarWidth,\n} from '@element-plus/utils'\nimport Scrollbar from '../components/scrollbar'\nimport { useGridWheel } from '../hooks/use-grid-wheel'\nimport { useCache } from '../hooks/use-cache'\nimport { virtualizedGridProps } from '../props'\nimport { getScrollDir, getRTLOffsetType, isRTL } from '../utils'\nimport {\n  AUTO_ALIGNMENT,\n  BACKWARD,\n  FORWARD,\n  RTL,\n  ITEM_RENDER_EVT,\n  SCROLL_EVT,\n  RTL_OFFSET_NAG,\n  RTL_OFFSET_POS_DESC,\n  RTL_OFFSET_POS_ASC,\n} from '../defaults'\n\nimport type { CSSProperties, VNode, VNodeChild, StyleValue } from 'vue'\nimport type { GridConstructorProps, Alignment, ScrollbarExpose } from '../types'\nimport type { VirtualizedGridProps } from '../props'\n\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n\n  initCache,\n  validateProps,\n}: GridConstructorProps<VirtualizedGridProps>) => {\n  return defineComponent({\n    name: name ?? 'ElVirtualList',\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose, slots }) {\n      validateProps(props)\n      const instance = getCurrentInstance()!\n      const cache = ref(initCache(props, instance))\n      // refs\n      // here windowRef and innerRef can be type of HTMLElement\n      // or user defined component type, depends on the type passed\n      // by user\n      const windowRef = ref<HTMLElement>()\n      const hScrollbar = ref<ScrollbarExpose>()\n      const vScrollbar = ref<ScrollbarExpose>()\n      // innerRef is the actual container element which contains all the elements\n      const innerRef = ref(null)\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD,\n      })\n\n      const getItemStyleCache = useCache()\n\n      // computed\n      const parsedHeight = computed(() => parseInt(`${props.height}`, 10))\n      const parsedWidth = computed(() => parseInt(`${props.width}`, 10))\n      const columnsToRender = computed(() => {\n        const { totalColumn, totalRow, columnCache } = props\n        const { isScrolling, xAxisScrollDir, scrollLeft } = unref(states)\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getColumnStartIndexForOffset(\n          props,\n          scrollLeft,\n          unref(cache)\n        )\n        const stopIndex = getColumnStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollLeft,\n          unref(cache)\n        )\n\n        const cacheBackward =\n          !isScrolling || xAxisScrollDir === BACKWARD\n            ? Math.max(1, columnCache)\n            : 1\n        const cacheForward =\n          !isScrolling || xAxisScrollDir === FORWARD\n            ? Math.max(1, columnCache)\n            : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalColumn! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const rowsToRender = computed(() => {\n        const { totalColumn, totalRow, rowCache } = props\n        const { isScrolling, yAxisScrollDir, scrollTop } = unref(states)\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0]\n        }\n\n        const startIndex = getRowStartIndexForOffset(\n          props,\n          scrollTop,\n          unref(cache)\n        )\n        const stopIndex = getRowStopIndexForStartIndex(\n          props,\n          startIndex,\n          scrollTop,\n          unref(cache)\n        )\n\n        const cacheBackward =\n          !isScrolling || yAxisScrollDir === BACKWARD\n            ? Math.max(1, rowCache)\n            : 1\n        const cacheForward =\n          !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1\n\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalRow! - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex,\n        ]\n      })\n\n      const estimatedTotalHeight = computed(() =>\n        getEstimatedTotalHeight(props, unref(cache))\n      )\n      const estimatedTotalWidth = computed(() =>\n        getEstimatedTotalWidth(props, unref(cache))\n      )\n\n      const windowStyle = computed<StyleValue>(() => [\n        {\n          position: 'relative',\n          overflow: 'hidden',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width,\n        },\n        props.style ?? {},\n      ])\n\n      const innerStyle = computed(() => {\n        const width = `${unref(estimatedTotalWidth)}px`\n        const height = `${unref(estimatedTotalHeight)}px`\n\n        return {\n          height,\n          pointerEvents: unref(states).isScrolling ? 'none' : undefined,\n          width,\n        }\n      })\n\n      // methods\n      const emitEvents = () => {\n        const { totalColumn, totalRow } = props\n\n        if (totalColumn! > 0 && totalRow! > 0) {\n          const [\n            columnCacheStart,\n            columnCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n          ] = unref(columnsToRender)\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] =\n            unref(rowsToRender)\n          // emit the render item event with\n          // [xAxisInvisibleStart, xAxisInvisibleEnd, xAxisVisibleStart, xAxisVisibleEnd]\n          // [yAxisInvisibleStart, yAxisInvisibleEnd, yAxisVisibleStart, yAxisVisibleEnd]\n          emit(\n            ITEM_RENDER_EVT,\n            columnCacheStart,\n            columnCacheEnd,\n            rowCacheStart,\n            rowCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n            rowVisibleStart,\n            rowVisibleEnd\n          )\n        }\n\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir,\n        } = unref(states)\n        emit(\n          SCROLL_EVT,\n          xAxisScrollDir,\n          scrollLeft,\n          yAxisScrollDir,\n          scrollTop,\n          updateRequested\n        )\n      }\n\n      const onScroll = (e: Event) => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth,\n        } = e.currentTarget as HTMLElement\n\n        const _states = unref(states)\n        if (\n          _states.scrollTop === scrollTop &&\n          _states.scrollLeft === scrollLeft\n        ) {\n          return\n        }\n\n        let _scrollLeft = scrollLeft\n\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft\n              break\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft\n              break\n          }\n        }\n\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(\n            0,\n            Math.min(scrollTop, scrollHeight - clientHeight)\n          ),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n        }\n\n        nextTick(resetIsScrolling)\n\n        emitEvents()\n      }\n\n      const onVerticalScroll = (distance: number, totalSteps: number) => {\n        const height = unref(parsedHeight)\n        const offset =\n          ((estimatedTotalHeight.value - height) / totalSteps) * distance\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset),\n        })\n      }\n\n      const onHorizontalScroll = (distance: number, totalSteps: number) => {\n        const width = unref(parsedWidth)\n        const offset =\n          ((estimatedTotalWidth.value - width) / totalSteps) * distance\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset),\n        })\n      }\n\n      const { onWheel } = useGridWheel(\n        {\n          atXStartEdge: computed(() => states.value.scrollLeft <= 0),\n          atXEndEdge: computed(\n            () => states.value.scrollLeft >= estimatedTotalWidth.value\n          ),\n          atYStartEdge: computed(() => states.value.scrollTop <= 0),\n          atYEndEdge: computed(\n            () => states.value.scrollTop >= estimatedTotalHeight.value\n          ),\n        },\n        (x: number, y: number) => {\n          hScrollbar.value?.onMouseUp?.()\n          hScrollbar.value?.onMouseUp?.()\n          const width = unref(parsedWidth)\n          const height = unref(parsedHeight)\n          scrollTo({\n            scrollLeft: Math.min(\n              states.value.scrollLeft + x,\n              estimatedTotalWidth.value - width\n            ),\n            scrollTop: Math.min(\n              states.value.scrollTop + y,\n              estimatedTotalHeight.value - height\n            ),\n          })\n        }\n      )\n\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop,\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0)\n        scrollTop = Math.max(scrollTop, 0)\n        const _states = unref(states)\n        if (\n          scrollTop === _states.scrollTop &&\n          scrollLeft === _states.scrollLeft\n        ) {\n          return\n        }\n\n        states.value = {\n          ..._states,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true,\n        }\n\n        nextTick(resetIsScrolling)\n      }\n\n      const scrollToItem = (\n        rowIndex = 0,\n        columnIdx = 0,\n        alignment: Alignment = AUTO_ALIGNMENT\n      ) => {\n        const _states = unref(states)\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn! - 1))\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow! - 1))\n        const scrollBarWidth = getScrollBarWidth()\n\n        const _cache = unref(cache)\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache)\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache)\n\n        scrollTo({\n          scrollLeft: getColumnOffset(\n            props,\n            columnIdx,\n            alignment,\n            _states.scrollLeft,\n            _cache,\n            estimatedWidth > props.width! ? scrollBarWidth : 0\n          ),\n          scrollTop: getRowOffset(\n            props,\n            rowIndex,\n            alignment,\n            _states.scrollTop,\n            _cache,\n            estimatedHeight > props.height! ? scrollBarWidth : 0\n          ),\n        })\n      }\n\n      const getItemStyle = (\n        rowIndex: number,\n        columnIndex: number\n      ): CSSProperties => {\n        const { columnWidth, direction, rowHeight } = props\n\n        const itemStyleCache = getItemStyleCache.value(\n          clearCache && columnWidth,\n          clearCache && rowHeight,\n          clearCache && direction\n        )\n        // since there was no need to introduce an nested array into cache object\n        // we use row,column to construct the key for indexing the map.\n        const key = `${rowIndex},${columnIndex}`\n\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key]\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, unref(cache))\n          const _cache = unref(cache)\n\n          const rtl = isRTL(direction)\n          const [height, top] = getRowPosition(props, rowIndex, _cache)\n          const [width] = getColumnPosition(props, columnIndex, _cache)\n\n          itemStyleCache[key] = {\n            position: 'absolute',\n            left: rtl ? undefined : `${left}px`,\n            right: rtl ? `${left}px` : undefined,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`,\n          }\n\n          return itemStyleCache[key]\n        }\n      }\n\n      // TODO: debounce setting is scrolling.\n\n      const resetIsScrolling = () => {\n        // timer = null\n\n        states.value.isScrolling = false\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null)\n        })\n      }\n\n      // life cycles\n      onMounted(() => {\n        // for SSR\n        if (!isClient) return\n        const { initScrollLeft, initScrollTop } = props\n        const windowElement = unref(windowRef)\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop\n          }\n        }\n        emitEvents()\n      })\n\n      onUpdated(() => {\n        const { direction } = props\n        const { scrollLeft, scrollTop, updateRequested } = unref(states)\n\n        const windowElement = unref(windowRef)\n\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG: {\n                windowElement.scrollLeft = -scrollLeft\n                break\n              }\n              case RTL_OFFSET_POS_ASC: {\n                windowElement.scrollLeft = scrollLeft\n                break\n              }\n              default: {\n                const { clientWidth, scrollWidth } = windowElement\n                windowElement.scrollLeft =\n                  scrollWidth - clientWidth - scrollLeft\n                break\n              }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft)\n          }\n\n          windowElement.scrollTop = Math.max(0, scrollTop)\n        }\n      })\n\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states,\n      })\n\n      // rendering part\n\n      const renderScrollbars = () => {\n        const { totalColumn, totalRow } = props\n\n        const width = unref(parsedWidth)\n        const height = unref(parsedHeight)\n        const estimatedWidth = unref(estimatedTotalWidth)\n        const estimatedHeight = unref(estimatedTotalHeight)\n        const { scrollLeft, scrollTop } = unref(states)\n        const horizontalScrollbar = h(Scrollbar, {\n          ref: hScrollbar,\n          clientSize: width,\n          layout: 'horizontal',\n          onScroll: onHorizontalScroll,\n          ratio: (width * 100) / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true,\n        })\n\n        const verticalScrollbar = h(Scrollbar, {\n          ref: vScrollbar,\n          clientSize: height,\n          layout: 'vertical',\n          onScroll: onVerticalScroll,\n          ratio: (height * 100) / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true,\n        })\n\n        return {\n          horizontalScrollbar,\n          verticalScrollbar,\n        }\n      }\n\n      const renderItems = () => {\n        const [columnStart, columnEnd] = unref(columnsToRender)\n        const [rowStart, rowEnd] = unref(rowsToRender)\n        const { data, totalColumn, totalRow, useIsScrolling } = props\n        const children: VNodeChild[] = []\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              children.push(\n                slots.default?.({\n                  columnIndex: column,\n                  data,\n                  key: column,\n                  isScrolling: useIsScrolling\n                    ? unref(states).isScrolling\n                    : undefined,\n                  style: getItemStyle(row, column),\n                  rowIndex: row,\n                })\n              )\n            }\n          }\n        }\n        return children\n      }\n\n      const renderInner = () => {\n        const Inner = resolveDynamicComponent(props.innerElement) as VNode\n        const children = renderItems()\n        return [\n          h(\n            Inner,\n            {\n              style: unref(innerStyle),\n              ref: innerRef,\n            },\n            !isString(Inner)\n              ? {\n                  default: () => children,\n                }\n              : children\n          ),\n        ]\n      }\n\n      const renderWindow = () => {\n        const Container = resolveDynamicComponent(\n          props.containerElement\n        ) as VNode\n        const { horizontalScrollbar, verticalScrollbar } = renderScrollbars()\n        const Inner = renderInner()\n\n        return h(\n          'div',\n          {\n            key: 0,\n            class: 'el-vg__wrapper',\n          },\n          [\n            h(\n              Container,\n              {\n                class: props.className,\n                style: unref(windowStyle),\n                onScroll,\n                onWheel,\n                ref: windowRef,\n              },\n              !isString(Container) ? { default: () => Inner } : Inner\n            ),\n            horizontalScrollbar,\n            verticalScrollbar,\n          ]\n        )\n      }\n\n      return renderWindow\n    },\n  })\n}\nexport default createGrid\n"]},"metadata":{},"sourceType":"module"}
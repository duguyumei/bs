{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { createPopper } from '@popperjs/core';\nimport { get } from 'lodash-unified';\nimport '../../../utils/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { hasOwn } from '@vue/shared';\nimport { useZIndex } from '../../../hooks/use-z-index/index.mjs';\nimport { off, on } from '../../../utils/dom/event.mjs';\n\nconst getCell = function (event) {\n  let cell = event.target;\n\n  while (cell && cell.tagName.toUpperCase() !== \"HTML\") {\n    if (cell.tagName.toUpperCase() === \"TD\") {\n      return cell;\n    }\n\n    cell = cell.parentNode;\n  }\n\n  return null;\n};\n\nconst isObject = function (obj) {\n  return obj !== null && typeof obj === \"object\";\n};\n\nconst orderBy = function (array, sortKey, reverse, sortMethod, sortBy) {\n  if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {\n    return array;\n  }\n\n  if (typeof reverse === \"string\") {\n    reverse = reverse === \"descending\" ? -1 : 1;\n  } else {\n    reverse = reverse && reverse < 0 ? -1 : 1;\n  }\n\n  const getKey = sortMethod ? null : function (value, index) {\n    if (sortBy) {\n      if (!Array.isArray(sortBy)) {\n        sortBy = [sortBy];\n      }\n\n      return sortBy.map(function (by) {\n        if (typeof by === \"string\") {\n          return get(value, by);\n        } else {\n          return by(value, index, array);\n        }\n      });\n    }\n\n    if (sortKey !== \"$key\") {\n      if (isObject(value) && \"$value\" in value) value = value.$value;\n    }\n\n    return [isObject(value) ? get(value, sortKey) : value];\n  };\n\n  const compare = function (a, b) {\n    if (sortMethod) {\n      return sortMethod(a.value, b.value);\n    }\n\n    for (let i = 0, len = a.key.length; i < len; i++) {\n      if (a.key[i] < b.key[i]) {\n        return -1;\n      }\n\n      if (a.key[i] > b.key[i]) {\n        return 1;\n      }\n    }\n\n    return 0;\n  };\n\n  return array.map(function (value, index) {\n    return {\n      value,\n      index,\n      key: getKey ? getKey(value, index) : null\n    };\n  }).sort(function (a, b) {\n    let order = compare(a, b);\n\n    if (!order) {\n      order = a.index - b.index;\n    }\n\n    return order * +reverse;\n  }).map(item => item.value);\n};\n\nconst getColumnById = function (table, columnId) {\n  let column = null;\n  table.columns.forEach(function (item) {\n    if (item.id === columnId) {\n      column = item;\n    }\n  });\n  return column;\n};\n\nconst getColumnByKey = function (table, columnKey) {\n  let column = null;\n\n  for (let i = 0; i < table.columns.length; i++) {\n    const item = table.columns[i];\n\n    if (item.columnKey === columnKey) {\n      column = item;\n      break;\n    }\n  }\n\n  return column;\n};\n\nconst getColumnByCell = function (table, cell, namespace) {\n  const matches = (cell.className || \"\").match(new RegExp(`${namespace}-table_[^\\\\s]+`, \"gm\"));\n\n  if (matches) {\n    return getColumnById(table, matches[0]);\n  }\n\n  return null;\n};\n\nconst getRowIdentity = (row, rowKey) => {\n  if (!row) throw new Error(\"Row is required when get row identity\");\n\n  if (typeof rowKey === \"string\") {\n    if (rowKey.indexOf(\".\") < 0) {\n      return `${row[rowKey]}`;\n    }\n\n    const key = rowKey.split(\".\");\n    let current = row;\n\n    for (let i = 0; i < key.length; i++) {\n      current = current[key[i]];\n    }\n\n    return `${current}`;\n  } else if (typeof rowKey === \"function\") {\n    return rowKey.call(null, row);\n  }\n};\n\nconst getKeysMap = function (array, rowKey) {\n  const arrayMap = {};\n  (array || []).forEach((row, index) => {\n    arrayMap[getRowIdentity(row, rowKey)] = {\n      row,\n      index\n    };\n  });\n  return arrayMap;\n};\n\nfunction mergeOptions(defaults, config) {\n  const options = {};\n  let key;\n\n  for (key in defaults) {\n    options[key] = defaults[key];\n  }\n\n  for (key in config) {\n    if (hasOwn(config, key)) {\n      const value = config[key];\n\n      if (typeof value !== \"undefined\") {\n        options[key] = value;\n      }\n    }\n  }\n\n  return options;\n}\n\nfunction parseWidth(width) {\n  if (width === \"\") return width;\n\n  if (width !== void 0) {\n    width = parseInt(width, 10);\n\n    if (Number.isNaN(width)) {\n      width = \"\";\n    }\n  }\n\n  return width;\n}\n\nfunction parseMinWidth(minWidth) {\n  if (minWidth === \"\") return minWidth;\n\n  if (minWidth !== void 0) {\n    minWidth = parseWidth(minWidth);\n\n    if (Number.isNaN(minWidth)) {\n      minWidth = 80;\n    }\n  }\n\n  return minWidth;\n}\n\nfunction parseHeight(height) {\n  if (typeof height === \"number\") {\n    return height;\n  }\n\n  if (typeof height === \"string\") {\n    if (/^\\d+(?:px)?$/.test(height)) {\n      return parseInt(height, 10);\n    } else {\n      return height;\n    }\n  }\n\n  return null;\n}\n\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\nfunction toggleRowStatus(statusArr, row, newVal) {\n  let changed = false;\n  const index = statusArr.indexOf(row);\n  const included = index !== -1;\n\n  const addRow = () => {\n    statusArr.push(row);\n    changed = true;\n  };\n\n  const removeRow = () => {\n    statusArr.splice(index, 1);\n    changed = true;\n  };\n\n  if (typeof newVal === \"boolean\") {\n    if (newVal && !included) {\n      addRow();\n    } else if (!newVal && included) {\n      removeRow();\n    }\n  } else {\n    if (included) {\n      removeRow();\n    } else {\n      addRow();\n    }\n  }\n\n  return changed;\n}\n\nfunction walkTreeNode(root, cb, childrenKey = \"children\", lazyKey = \"hasChildren\") {\n  const isNil = array => !(Array.isArray(array) && array.length);\n\n  function _walker(parent, children, level) {\n    cb(parent, children, level);\n    children.forEach(item => {\n      if (item[lazyKey]) {\n        cb(item, null, level + 1);\n        return;\n      }\n\n      const children2 = item[childrenKey];\n\n      if (!isNil(children2)) {\n        _walker(item, children2, level + 1);\n      }\n    });\n  }\n\n  root.forEach(item => {\n    if (item[lazyKey]) {\n      cb(item, null, 0);\n      return;\n    }\n\n    const children = item[childrenKey];\n\n    if (!isNil(children)) {\n      _walker(item, children, 0);\n    }\n  });\n}\n\nlet removePopper;\n\nfunction createTablePopper(trigger, popperContent, popperOptions, tooltipEffect) {\n  const {\n    nextZIndex\n  } = useZIndex();\n\n  function renderContent() {\n    const isLight = tooltipEffect === \"light\";\n    const content2 = document.createElement(\"div\");\n    content2.className = `el-popper ${isLight ? \"is-light\" : \"is-dark\"}`;\n    content2.innerHTML = popperContent;\n    content2.style.zIndex = String(nextZIndex());\n    document.body.appendChild(content2);\n    return content2;\n  }\n\n  function renderArrow() {\n    const arrow2 = document.createElement(\"div\");\n    arrow2.className = \"el-popper__arrow\";\n    return arrow2;\n  }\n\n  function showPopper() {\n    popperInstance && popperInstance.update();\n  }\n\n  removePopper = function removePopper2() {\n    try {\n      popperInstance && popperInstance.destroy();\n      content && document.body.removeChild(content);\n      off(trigger, \"mouseenter\", showPopper);\n      off(trigger, \"mouseleave\", removePopper2);\n    } catch (e) {}\n  };\n\n  let popperInstance = null;\n  const content = renderContent();\n  const arrow = renderArrow();\n  content.appendChild(arrow);\n  popperInstance = createPopper(trigger, content, {\n    modifiers: [{\n      name: \"offset\",\n      options: {\n        offset: [0, 8]\n      }\n    }, {\n      name: \"arrow\",\n      options: {\n        element: arrow,\n        padding: 10\n      }\n    }],\n    ...popperOptions\n  });\n  on(trigger, \"mouseenter\", showPopper);\n  on(trigger, \"mouseleave\", removePopper);\n  return popperInstance;\n}\n\nconst isFixedColumn = (index, fixed, store, realColumns) => {\n  let start = 0;\n  let after = index;\n\n  if (realColumns) {\n    if (realColumns[index].colSpan > 1) {\n      return {};\n    }\n\n    for (let i = 0; i < index; i++) {\n      start += realColumns[i].colSpan;\n    }\n\n    after = start + realColumns[index].colSpan - 1;\n  } else {\n    start = index;\n  }\n\n  let fixedLayout;\n  const columns = store.states.columns;\n\n  switch (fixed) {\n    case \"left\":\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = \"left\";\n      }\n\n      break;\n\n    case \"right\":\n      if (start >= columns.value.length - store.states.rightFixedLeafColumnsLength.value) {\n        fixedLayout = \"right\";\n      }\n\n      break;\n\n    default:\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = \"left\";\n      } else if (start >= columns.value.length - store.states.rightFixedLeafColumnsLength.value) {\n        fixedLayout = \"right\";\n      }\n\n  }\n\n  return fixedLayout ? {\n    direction: fixedLayout,\n    start,\n    after\n  } : {};\n};\n\nconst getFixedColumnsClass = (namespace, index, fixed, store, realColumns) => {\n  const classes = [];\n  const {\n    direction,\n    start\n  } = isFixedColumn(index, fixed, store, realColumns);\n\n  if (direction) {\n    const isLeft = direction === \"left\";\n    classes.push(`${namespace}-fixed-column--${direction}`);\n\n    if (isLeft && start === store.states.fixedLeafColumnsLength.value - 1) {\n      classes.push(\"is-last-column\");\n    } else if (!isLeft && start === store.states.columns.value.length - store.states.rightFixedLeafColumnsLength.value) {\n      classes.push(\"is-first-column\");\n    }\n  }\n\n  return classes;\n};\n\nfunction getOffset(offset, column) {\n  return offset + (column.realWidth === null || Number.isNaN(column.realWidth) ? Number(column.width) : column.realWidth);\n}\n\nconst getFixedColumnOffset = (index, fixed, store, realColumns) => {\n  const {\n    direction,\n    start = 0\n  } = isFixedColumn(index, fixed, store, realColumns);\n\n  if (!direction) {\n    return;\n  }\n\n  const styles = {};\n  const isLeft = direction === \"left\";\n  const columns = store.states.columns.value;\n\n  if (isLeft) {\n    styles.left = columns.slice(0, index).reduce(getOffset, 0);\n  } else {\n    styles.right = columns.slice(start + 1).reverse().reduce(getOffset, 0);\n  }\n\n  return styles;\n};\n\nconst ensurePosition = (style, key) => {\n  if (!style) return;\n\n  if (!Number.isNaN(style[key])) {\n    style[key] = `${style[key]}px`;\n  }\n};\n\nexport { compose, createTablePopper, ensurePosition, getCell, getColumnByCell, getColumnById, getColumnByKey, getFixedColumnOffset, getFixedColumnsClass, getKeysMap, getRowIdentity, isFixedColumn, mergeOptions, orderBy, parseHeight, parseMinWidth, parseWidth, removePopper, toggleRowStatus, walkTreeNode };","map":{"version":3,"mappings":"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","names":["getCell","event","cell","target","tagName","toUpperCase","parentNode","isObject","obj","orderBy","array","sortKey","reverse","sortMethod","sortBy","Array","isArray","length","getKey","value","index","map","by","get","$value","compare","a","b","i","len","key","sort","order","item","getColumnById","table","columnId","column","columns","forEach","id","getColumnByKey","columnKey","getColumnByCell","namespace","matches","className","match","RegExp","getRowIdentity","row","rowKey","Error","indexOf","split","current","call","getKeysMap","arrayMap","mergeOptions","defaults","config","options","hasOwn","parseWidth","width","parseInt","Number","isNaN","parseMinWidth","minWidth","parseHeight","height","test","compose","funcs","arg","reduce","args","toggleRowStatus","statusArr","newVal","changed","included","addRow","push","removeRow","splice","walkTreeNode","root","cb","childrenKey","lazyKey","isNil","_walker","parent","children","level","children2","removePopper","createTablePopper","trigger","popperContent","popperOptions","tooltipEffect","nextZIndex","useZIndex","renderContent","isLight","content2","document","createElement","innerHTML","style","zIndex","String","body","appendChild","renderArrow","arrow2","showPopper","popperInstance","update","removePopper2","destroy","content","removeChild","off","e","arrow","createPopper","modifiers","name","offset","element","padding","on","isFixedColumn","fixed","store","realColumns","start","after","colSpan","fixedLayout","states","fixedLeafColumnsLength","rightFixedLeafColumnsLength","direction","getFixedColumnsClass","classes","isLeft","getOffset","realWidth","getFixedColumnOffset","styles","left","slice","right","ensurePosition"],"sources":["../../../../../../packages/components/table/src/util.ts"],"sourcesContent":["import { createPopper } from '@popperjs/core'\nimport { get } from 'lodash-unified'\nimport { hasOwn, off, on } from '@element-plus/utils'\nimport { useZIndex } from '@element-plus/hooks'\nimport type {\n  PopperInstance,\n  IPopperOptions,\n} from '@element-plus/components/popper'\nimport type { Nullable } from '@element-plus/utils'\nimport type { TableColumnCtx } from './table-column/defaults'\n\nexport const getCell = function (event: Event): HTMLElement {\n  let cell = event.target as HTMLElement\n\n  while (cell && cell.tagName.toUpperCase() !== 'HTML') {\n    if (cell.tagName.toUpperCase() === 'TD') {\n      return cell\n    }\n    cell = cell.parentNode as HTMLElement\n  }\n\n  return null\n}\n\nconst isObject = function (obj: unknown): boolean {\n  return obj !== null && typeof obj === 'object'\n}\n\nexport const orderBy = function <T>(\n  array: T[],\n  sortKey: string,\n  reverse: string | number,\n  sortMethod,\n  sortBy: string | (string | ((a: T, b: T, array?: T[]) => number))[]\n) {\n  if (\n    !sortKey &&\n    !sortMethod &&\n    (!sortBy || (Array.isArray(sortBy) && !sortBy.length))\n  ) {\n    return array\n  }\n  if (typeof reverse === 'string') {\n    reverse = reverse === 'descending' ? -1 : 1\n  } else {\n    reverse = reverse && reverse < 0 ? -1 : 1\n  }\n  const getKey = sortMethod\n    ? null\n    : function (value, index) {\n        if (sortBy) {\n          if (!Array.isArray(sortBy)) {\n            sortBy = [sortBy]\n          }\n          return sortBy.map(function (by) {\n            if (typeof by === 'string') {\n              return get(value, by)\n            } else {\n              return by(value, index, array)\n            }\n          })\n        }\n        if (sortKey !== '$key') {\n          if (isObject(value) && '$value' in value) value = value.$value\n        }\n        return [isObject(value) ? get(value, sortKey) : value]\n      }\n  const compare = function (a, b) {\n    if (sortMethod) {\n      return sortMethod(a.value, b.value)\n    }\n    for (let i = 0, len = a.key.length; i < len; i++) {\n      if (a.key[i] < b.key[i]) {\n        return -1\n      }\n      if (a.key[i] > b.key[i]) {\n        return 1\n      }\n    }\n    return 0\n  }\n  return array\n    .map(function (value, index) {\n      return {\n        value,\n        index,\n        key: getKey ? getKey(value, index) : null,\n      }\n    })\n    .sort(function (a, b) {\n      let order = compare(a, b)\n      if (!order) {\n        // make stable https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n        order = a.index - b.index\n      }\n      return order * +reverse\n    })\n    .map((item) => item.value)\n}\n\nexport const getColumnById = function <T>(\n  table: {\n    columns: TableColumnCtx<T>[]\n  },\n  columnId: string\n): null | TableColumnCtx<T> {\n  let column = null\n  table.columns.forEach(function (item) {\n    if (item.id === columnId) {\n      column = item\n    }\n  })\n  return column\n}\n\nexport const getColumnByKey = function <T>(\n  table: {\n    columns: TableColumnCtx<T>[]\n  },\n  columnKey: string\n): TableColumnCtx<T> {\n  let column = null\n  for (let i = 0; i < table.columns.length; i++) {\n    const item = table.columns[i]\n    if (item.columnKey === columnKey) {\n      column = item\n      break\n    }\n  }\n  return column\n}\n\nexport const getColumnByCell = function <T>(\n  table: {\n    columns: TableColumnCtx<T>[]\n  },\n  cell: HTMLElement,\n  namespace: string\n): null | TableColumnCtx<T> {\n  const matches = (cell.className || '').match(\n    new RegExp(`${namespace}-table_[^\\\\s]+`, 'gm')\n  )\n  if (matches) {\n    return getColumnById(table, matches[0])\n  }\n  return null\n}\n\nexport const getRowIdentity = <T>(\n  row: T,\n  rowKey: string | ((row: T) => any)\n): string => {\n  if (!row) throw new Error('Row is required when get row identity')\n  if (typeof rowKey === 'string') {\n    if (rowKey.indexOf('.') < 0) {\n      return `${row[rowKey]}`\n    }\n    const key = rowKey.split('.')\n    let current = row\n    for (let i = 0; i < key.length; i++) {\n      current = current[key[i]]\n    }\n    return `${current}`\n  } else if (typeof rowKey === 'function') {\n    return rowKey.call(null, row)\n  }\n}\n\nexport const getKeysMap = function <T>(\n  array: T[],\n  rowKey: string\n): Record<string, { row: T; index: number }> {\n  const arrayMap = {}\n  ;(array || []).forEach((row, index) => {\n    arrayMap[getRowIdentity(row, rowKey)] = { row, index }\n  })\n  return arrayMap\n}\n\nexport function mergeOptions<T, K>(defaults: T, config: K): T & K {\n  const options = {} as T & K\n  let key\n  for (key in defaults) {\n    options[key] = defaults[key]\n  }\n  for (key in config) {\n    if (hasOwn(config as unknown as Record<string, any>, key)) {\n      const value = config[key]\n      if (typeof value !== 'undefined') {\n        options[key] = value\n      }\n    }\n  }\n  return options\n}\n\nexport function parseWidth(width: number | string): number | string {\n  if (width === '') return width\n  if (width !== undefined) {\n    width = parseInt(width as string, 10)\n    if (Number.isNaN(width)) {\n      width = ''\n    }\n  }\n  return width\n}\n\nexport function parseMinWidth(minWidth: number | string): number | string {\n  if (minWidth === '') return minWidth\n  if (minWidth !== undefined) {\n    minWidth = parseWidth(minWidth)\n    if (Number.isNaN(minWidth)) {\n      minWidth = 80\n    }\n  }\n  return minWidth\n}\n\nexport function parseHeight(height: number | string) {\n  if (typeof height === 'number') {\n    return height\n  }\n  if (typeof height === 'string') {\n    if (/^\\d+(?:px)?$/.test(height)) {\n      return parseInt(height, 10)\n    } else {\n      return height\n    }\n  }\n  return null\n}\n\n// https://github.com/reduxjs/redux/blob/master/src/compose.js\nexport function compose(...funcs) {\n  if (funcs.length === 0) {\n    return (arg) => arg\n  }\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n  return funcs.reduce(\n    (a, b) =>\n      (...args) =>\n        a(b(...args))\n  )\n}\n\nexport function toggleRowStatus<T>(\n  statusArr: T[],\n  row: T,\n  newVal: boolean\n): boolean {\n  let changed = false\n  const index = statusArr.indexOf(row)\n  const included = index !== -1\n\n  const addRow = () => {\n    statusArr.push(row)\n    changed = true\n  }\n  const removeRow = () => {\n    statusArr.splice(index, 1)\n    changed = true\n  }\n\n  if (typeof newVal === 'boolean') {\n    if (newVal && !included) {\n      addRow()\n    } else if (!newVal && included) {\n      removeRow()\n    }\n  } else {\n    if (included) {\n      removeRow()\n    } else {\n      addRow()\n    }\n  }\n  return changed\n}\n\nexport function walkTreeNode(\n  root,\n  cb,\n  childrenKey = 'children',\n  lazyKey = 'hasChildren'\n) {\n  const isNil = (array) => !(Array.isArray(array) && array.length)\n\n  function _walker(parent, children, level) {\n    cb(parent, children, level)\n    children.forEach((item) => {\n      if (item[lazyKey]) {\n        cb(item, null, level + 1)\n        return\n      }\n      const children = item[childrenKey]\n      if (!isNil(children)) {\n        _walker(item, children, level + 1)\n      }\n    })\n  }\n\n  root.forEach((item) => {\n    if (item[lazyKey]) {\n      cb(item, null, 0)\n      return\n    }\n    const children = item[childrenKey]\n    if (!isNil(children)) {\n      _walker(item, children, 0)\n    }\n  })\n}\n\nexport let removePopper\n\nexport function createTablePopper(\n  trigger: HTMLElement,\n  popperContent: string,\n  popperOptions: Partial<IPopperOptions>,\n  tooltipEffect: string\n) {\n  const { nextZIndex } = useZIndex()\n  function renderContent(): HTMLDivElement {\n    const isLight = tooltipEffect === 'light'\n    const content = document.createElement('div')\n    content.className = `el-popper ${isLight ? 'is-light' : 'is-dark'}`\n    content.innerHTML = popperContent\n    content.style.zIndex = String(nextZIndex())\n    document.body.appendChild(content)\n    return content\n  }\n  function renderArrow(): HTMLDivElement {\n    const arrow = document.createElement('div')\n    arrow.className = 'el-popper__arrow'\n    return arrow\n  }\n  function showPopper() {\n    popperInstance && popperInstance.update()\n  }\n  removePopper = function removePopper() {\n    try {\n      popperInstance && popperInstance.destroy()\n      content && document.body.removeChild(content)\n      off(trigger, 'mouseenter', showPopper)\n      off(trigger, 'mouseleave', removePopper)\n    } catch {}\n  }\n  let popperInstance: Nullable<PopperInstance> = null\n  const content = renderContent()\n  const arrow = renderArrow()\n  content.appendChild(arrow)\n\n  popperInstance = createPopper(trigger, content, {\n    modifiers: [\n      {\n        name: 'offset',\n        options: {\n          offset: [0, 8],\n        },\n      },\n      {\n        name: 'arrow',\n        options: {\n          element: arrow,\n          padding: 10,\n        },\n      },\n    ],\n    ...popperOptions,\n  })\n  on(trigger, 'mouseenter', showPopper)\n  on(trigger, 'mouseleave', removePopper)\n  return popperInstance\n}\n\nexport const isFixedColumn = <T>(\n  index: number,\n  fixed: string | boolean,\n  store: any,\n  realColumns?: TableColumnCtx<T>[]\n) => {\n  let start = 0\n  let after = index\n  if (realColumns) {\n    if (realColumns[index].colSpan > 1) {\n      // fixed column not supported in grouped header\n      return {}\n    }\n    // handle group\n    for (let i = 0; i < index; i++) {\n      start += realColumns[i].colSpan\n    }\n    after = start + realColumns[index].colSpan - 1\n  } else {\n    start = index\n  }\n  let fixedLayout\n  const columns = store.states.columns\n  switch (fixed) {\n    case 'left':\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = 'left'\n      }\n      break\n    case 'right':\n      if (\n        start >=\n        columns.value.length - store.states.rightFixedLeafColumnsLength.value\n      ) {\n        fixedLayout = 'right'\n      }\n      break\n    default:\n      if (after < store.states.fixedLeafColumnsLength.value) {\n        fixedLayout = 'left'\n      } else if (\n        start >=\n        columns.value.length - store.states.rightFixedLeafColumnsLength.value\n      ) {\n        fixedLayout = 'right'\n      }\n  }\n  return fixedLayout\n    ? {\n        direction: fixedLayout,\n        start,\n        after,\n      }\n    : {}\n}\n\nexport const getFixedColumnsClass = <T>(\n  namespace: string,\n  index: number,\n  fixed: string | boolean,\n  store: any,\n  realColumns?: TableColumnCtx<T>[]\n) => {\n  const classes: string[] = []\n  const { direction, start } = isFixedColumn(index, fixed, store, realColumns)\n  if (direction) {\n    const isLeft = direction === 'left'\n    classes.push(`${namespace}-fixed-column--${direction}`)\n    if (isLeft && start === store.states.fixedLeafColumnsLength.value - 1) {\n      classes.push('is-last-column')\n    } else if (\n      !isLeft &&\n      start ===\n        store.states.columns.value.length -\n          store.states.rightFixedLeafColumnsLength.value\n    ) {\n      classes.push('is-first-column')\n    }\n  }\n  return classes\n}\n\nfunction getOffset<T>(offset: number, column: TableColumnCtx<T>) {\n  return (\n    offset +\n    (column.realWidth === null || Number.isNaN(column.realWidth)\n      ? Number(column.width)\n      : column.realWidth)\n  )\n}\n\nexport const getFixedColumnOffset = <T>(\n  index: number,\n  fixed: string | boolean,\n  store: any,\n  realColumns?: TableColumnCtx<T>[]\n) => {\n  const { direction, start = 0 } = isFixedColumn(\n    index,\n    fixed,\n    store,\n    realColumns\n  )\n  if (!direction) {\n    return\n  }\n  const styles: any = {}\n  const isLeft = direction === 'left'\n  const columns = store.states.columns.value\n  if (isLeft) {\n    styles.left = columns.slice(0, index).reduce(getOffset, 0)\n  } else {\n    styles.right = columns\n      .slice(start + 1)\n      .reverse()\n      .reduce(getOffset, 0)\n  }\n  return styles\n}\n\nexport const ensurePosition = (style, key: string) => {\n  if (!style) return\n  if (!Number.isNaN(style[key])) {\n    style[key] = `${style[key]}px`\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
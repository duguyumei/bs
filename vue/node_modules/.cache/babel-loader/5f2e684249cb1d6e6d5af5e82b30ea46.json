{"ast":null,"code":"import { ref, computed, defineComponent, watch, reactive, toRefs, provide, openBlock, createElementBlock, normalizeClass, renderSlot } from 'vue';\nimport '../../../tokens/index.mjs';\nimport '../../../utils/index.mjs';\nimport '../../../hooks/index.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { debugWarn } from '../../../utils/error.mjs';\nimport { useSize } from '../../../hooks/use-common-props/index.mjs';\nimport { elFormKey } from '../../../tokens/form.mjs';\n\nfunction useFormLabelWidth() {\n  const potentialLabelWidthArr = ref([]);\n  const autoLabelWidth = computed(() => {\n    if (!potentialLabelWidthArr.value.length) return \"0\";\n    const max = Math.max(...potentialLabelWidthArr.value);\n    return max ? `${max}px` : \"\";\n  });\n\n  function getLabelWidthIndex(width) {\n    const index = potentialLabelWidthArr.value.indexOf(width);\n\n    if (index === -1) {\n      debugWarn(\"Form\", `unexpected width ${width}`);\n    }\n\n    return index;\n  }\n\n  function registerLabelWidth(val, oldVal) {\n    if (val && oldVal) {\n      const index = getLabelWidthIndex(oldVal);\n      potentialLabelWidthArr.value.splice(index, 1, val);\n    } else if (val) {\n      potentialLabelWidthArr.value.push(val);\n    }\n  }\n\n  function deregisterLabelWidth(val) {\n    const index = getLabelWidthIndex(val);\n    index > -1 && potentialLabelWidthArr.value.splice(index, 1);\n  }\n\n  return {\n    autoLabelWidth,\n    registerLabelWidth,\n    deregisterLabelWidth\n  };\n}\n\nconst _sfc_main = defineComponent({\n  name: \"ElForm\",\n  props: {\n    model: Object,\n    rules: Object,\n    labelPosition: String,\n    labelWidth: {\n      type: [String, Number],\n      default: \"\"\n    },\n    labelSuffix: {\n      type: String,\n      default: \"\"\n    },\n    inline: Boolean,\n    inlineMessage: Boolean,\n    statusIcon: Boolean,\n    showMessage: {\n      type: Boolean,\n      default: true\n    },\n    size: String,\n    disabled: Boolean,\n    validateOnRuleChange: {\n      type: Boolean,\n      default: true\n    },\n    hideRequiredAsterisk: {\n      type: Boolean,\n      default: false\n    },\n    scrollToError: Boolean\n  },\n  emits: [\"validate\"],\n\n  setup(props, {\n    emit\n  }) {\n    const fields = [];\n    watch(() => props.rules, () => {\n      fields.forEach(field => {\n        field.evaluateValidationEnabled();\n      });\n\n      if (props.validateOnRuleChange) {\n        validate(() => ({}));\n      }\n    });\n    const formSize = useSize();\n    const prefix = \"el-form\";\n    const formKls = computed(() => {\n      const {\n        labelPosition,\n        inline\n      } = props;\n      return [prefix, `${prefix}--${formSize.value}`, labelPosition ? `${prefix}--label-${labelPosition}` : \"\", inline ? `${prefix}--inline` : \"\"];\n    });\n\n    const addField = field => {\n      if (field) {\n        fields.push(field);\n      }\n    };\n\n    const removeField = field => {\n      if (field.prop) {\n        fields.splice(fields.indexOf(field), 1);\n      }\n    };\n\n    const resetFields = () => {\n      if (!props.model) {\n        debugWarn(\"Form\", \"model is required for resetFields to work.\");\n        return;\n      }\n\n      fields.forEach(field => {\n        field.resetField();\n      });\n    };\n\n    const clearValidate = (props2 = []) => {\n      const fds = props2.length ? typeof props2 === \"string\" ? fields.filter(field => props2 === field.prop) : fields.filter(field => props2.indexOf(field.prop) > -1) : fields;\n      fds.forEach(field => {\n        field.clearValidate();\n      });\n    };\n\n    const validate = callback => {\n      if (!props.model) {\n        debugWarn(\"Form\", \"model is required for validate to work!\");\n        return;\n      }\n\n      let promise;\n\n      if (typeof callback !== \"function\") {\n        promise = new Promise((resolve, reject) => {\n          callback = function (valid2, invalidFields2) {\n            if (valid2) {\n              resolve(true);\n            } else {\n              reject(invalidFields2);\n            }\n          };\n        });\n      }\n\n      if (fields.length === 0) {\n        callback(true);\n      }\n\n      let valid = true;\n      let count = 0;\n      let invalidFields = {};\n      let firstInvalidFields;\n\n      for (const field of fields) {\n        field.validate(\"\", (message, field2) => {\n          if (message) {\n            valid = false;\n            firstInvalidFields || (firstInvalidFields = field2);\n          }\n\n          invalidFields = { ...invalidFields,\n            ...field2\n          };\n\n          if (++count === fields.length) {\n            callback(valid, invalidFields);\n          }\n        });\n      }\n\n      if (!valid && props.scrollToError) {\n        scrollToField(Object.keys(firstInvalidFields)[0]);\n      }\n\n      return promise;\n    };\n\n    const validateField = (props2, cb) => {\n      props2 = [].concat(props2);\n      const fds = fields.filter(field => props2.indexOf(field.prop) !== -1);\n\n      if (!fields.length) {\n        debugWarn(\"Form\", \"please pass correct props!\");\n        return;\n      }\n\n      fds.forEach(field => {\n        field.validate(\"\", cb);\n      });\n    };\n\n    const scrollToField = prop => {\n      fields.forEach(item => {\n        var _a, _b;\n\n        if (item.prop === prop) {\n          (_b = (_a = item.$el).scrollIntoView) == null ? void 0 : _b.call(_a);\n        }\n      });\n    };\n\n    const elForm = reactive({ ...toRefs(props),\n      resetFields,\n      clearValidate,\n      validateField,\n      emit,\n      addField,\n      removeField,\n      ...useFormLabelWidth()\n    });\n    provide(elFormKey, elForm);\n    return {\n      formKls,\n      validate,\n      resetFields,\n      clearValidate,\n      validateField,\n      scrollToField\n    };\n  }\n\n});\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"form\", {\n    class: normalizeClass(_ctx.formKls)\n  }, [renderSlot(_ctx.$slots, \"default\")], 2);\n}\n\nvar Form = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { Form as default };","map":{"version":3,"mappings":"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","names":["potentialLabelWidthArr","ref","autoLabelWidth","computed","value","length","max","Math","width","index","indexOf","debugWarn","val","oldVal","getLabelWidthIndex","splice","push","registerLabelWidth","deregisterLabelWidth","_sfc_main","defineComponent","name","props","model","Object","rules","labelPosition","String","labelWidth","type","Number","default","labelSuffix","inline","Boolean","inlineMessage","statusIcon","showMessage","size","disabled","validateOnRuleChange","hideRequiredAsterisk","scrollToError","emits","setup","emit","fields","watch","forEach","field","evaluateValidationEnabled","validate","formSize","useSize","prefix","formKls","addField","removeField","prop","resetFields","resetField","clearValidate","props2","fds","filter","callback","promise","Promise","resolve","reject","valid2","invalidFields2","valid","count","invalidFields","firstInvalidFields","message","field2","scrollToField","keys","validateField","cb","concat","item","_a","_b","provide","$setup","class","renderSlot"],"sources":["../../../../../../packages/components/form/src/form.vue"],"sourcesContent":["<template>\n  <form :class=\"formKls\">\n    <slot></slot>\n  </form>\n</template>\n\n<script lang=\"ts\">\nimport {\n  computed,\n  defineComponent,\n  provide,\n  reactive,\n  ref,\n  toRefs,\n  watch,\n} from 'vue'\nimport { elFormKey } from '@element-plus/tokens'\nimport { debugWarn } from '@element-plus/utils'\nimport { useSize } from '@element-plus/hooks'\nimport type { ValidateFieldsError } from 'async-validator'\n\nimport type { PropType } from 'vue'\nimport type { ComponentSize } from '@element-plus/constants'\nimport type { FormRulesMap } from './form.type'\nimport type {\n  ElFormItemContext as FormItemCtx,\n  ValidateFieldCallback,\n} from '@element-plus/tokens'\n\nfunction useFormLabelWidth() {\n  const potentialLabelWidthArr = ref([])\n  const autoLabelWidth = computed(() => {\n    if (!potentialLabelWidthArr.value.length) return '0'\n    const max = Math.max(...potentialLabelWidthArr.value)\n    return max ? `${max}px` : ''\n  })\n\n  function getLabelWidthIndex(width: number) {\n    const index = potentialLabelWidthArr.value.indexOf(width)\n    if (index === -1) {\n      debugWarn('Form', `unexpected width ${width}`)\n    }\n    return index\n  }\n\n  function registerLabelWidth(val: number, oldVal: number) {\n    if (val && oldVal) {\n      const index = getLabelWidthIndex(oldVal)\n      potentialLabelWidthArr.value.splice(index, 1, val)\n    } else if (val) {\n      potentialLabelWidthArr.value.push(val)\n    }\n  }\n\n  function deregisterLabelWidth(val: number) {\n    const index = getLabelWidthIndex(val)\n    index > -1 && potentialLabelWidthArr.value.splice(index, 1)\n  }\n\n  return {\n    autoLabelWidth,\n    registerLabelWidth,\n    deregisterLabelWidth,\n  }\n}\n\nexport interface Callback {\n  (isValid?: boolean, invalidFields?: ValidateFieldsError): void\n}\n\nexport default defineComponent({\n  name: 'ElForm',\n  props: {\n    model: Object,\n    rules: Object as PropType<FormRulesMap>,\n    labelPosition: String,\n    labelWidth: {\n      type: [String, Number],\n      default: '',\n    },\n    labelSuffix: {\n      type: String,\n      default: '',\n    },\n    inline: Boolean,\n    inlineMessage: Boolean,\n    statusIcon: Boolean,\n    showMessage: {\n      type: Boolean,\n      default: true,\n    },\n    size: String as PropType<ComponentSize>,\n    disabled: Boolean,\n    validateOnRuleChange: {\n      type: Boolean,\n      default: true,\n    },\n    hideRequiredAsterisk: {\n      type: Boolean,\n      default: false,\n    },\n    scrollToError: Boolean,\n  },\n  emits: ['validate'],\n  setup(props, { emit }) {\n    const fields: FormItemCtx[] = []\n\n    watch(\n      () => props.rules,\n      () => {\n        fields.forEach((field) => {\n          field.evaluateValidationEnabled()\n        })\n\n        if (props.validateOnRuleChange) {\n          validate(() => ({}))\n        }\n      }\n    )\n\n    const formSize = useSize()\n    const prefix = 'el-form'\n    const formKls = computed(() => {\n      const { labelPosition, inline } = props\n      return [\n        prefix,\n        `${prefix}--${formSize.value}`,\n        labelPosition ? `${prefix}--label-${labelPosition}` : '',\n        inline ? `${prefix}--inline` : '',\n      ]\n    })\n\n    const addField = (field: FormItemCtx) => {\n      if (field) {\n        fields.push(field)\n      }\n    }\n\n    const removeField = (field: FormItemCtx) => {\n      if (field.prop) {\n        fields.splice(fields.indexOf(field), 1)\n      }\n    }\n\n    const resetFields = () => {\n      if (!props.model) {\n        debugWarn('Form', 'model is required for resetFields to work.')\n        return\n      }\n      fields.forEach((field) => {\n        field.resetField()\n      })\n    }\n\n    const clearValidate = (props: string | string[] = []) => {\n      const fds = props.length\n        ? typeof props === 'string'\n          ? fields.filter((field) => props === field.prop)\n          : fields.filter((field) => props.indexOf(field.prop) > -1)\n        : fields\n      fds.forEach((field) => {\n        field.clearValidate()\n      })\n    }\n\n    const validate = (callback?: Callback) => {\n      if (!props.model) {\n        debugWarn('Form', 'model is required for validate to work!')\n        return\n      }\n\n      let promise: Promise<boolean> | undefined\n      // if no callback, return promise\n      if (typeof callback !== 'function') {\n        promise = new Promise((resolve, reject) => {\n          callback = function (valid, invalidFields) {\n            if (valid) {\n              resolve(true)\n            } else {\n              reject(invalidFields)\n            }\n          }\n        })\n      }\n\n      if (fields.length === 0) {\n        callback(true)\n      }\n      let valid = true\n      let count = 0\n      let invalidFields = {}\n      let firstInvalidFields\n      for (const field of fields) {\n        field.validate('', (message, field) => {\n          if (message) {\n            valid = false\n            firstInvalidFields || (firstInvalidFields = field)\n          }\n          invalidFields = { ...invalidFields, ...field }\n          if (++count === fields.length) {\n            callback(valid, invalidFields)\n          }\n        })\n      }\n      if (!valid && props.scrollToError) {\n        scrollToField(Object.keys(firstInvalidFields)[0])\n      }\n      return promise\n    }\n\n    const validateField = (\n      props: string | string[],\n      cb: ValidateFieldCallback\n    ) => {\n      props = [].concat(props)\n      const fds = fields.filter((field) => props.indexOf(field.prop) !== -1)\n      if (!fields.length) {\n        debugWarn('Form', 'please pass correct props!')\n        return\n      }\n\n      fds.forEach((field) => {\n        field.validate('', cb)\n      })\n    }\n\n    const scrollToField = (prop: string) => {\n      fields.forEach((item) => {\n        if (item.prop === prop) {\n          item.$el.scrollIntoView?.()\n        }\n      })\n    }\n\n    const elForm = reactive({\n      ...toRefs(props),\n      resetFields,\n      clearValidate,\n      validateField,\n      emit,\n      addField,\n      removeField,\n      ...useFormLabelWidth(),\n    })\n\n    provide(elFormKey, elForm)\n\n    return {\n      formKls,\n      validate, // export\n      resetFields,\n      clearValidate,\n      validateField,\n      scrollToField,\n    }\n  },\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}